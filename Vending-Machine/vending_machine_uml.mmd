```mermaid
classDiagram
    %% Enums
    class CoinType {
        <<enumeration>>
        +PENNY
        +NICKEL
        +DIME
        +QUARTER
        +DOLLAR
        +getValue() int
    }

    class MachineState {
        <<enumeration>>
        +IDLE
        +SELECTING
        +PAYMENT
        +DISPENSING
        +getDescription() String
    }

    class PaymentMethod {
        <<enumeration>>
        +CASH
        +CARD
        +MOBILE
        +getDescription() String
    }

    class ProductType {
        <<enumeration>>
        +CHIPS
        +CHOCOLATE
        +SODA
        +CANDY
        +GUM
        +WATER
        +getName() String
        +getPriceInCents() int
    }

    class TransactionStatus {
        <<enumeration>>
        +PENDING
        +PROCESSING
        +COMPLETED
        +FAILED
        +CANCELLED
        +REFUNDING
        +getDescription() String
    }

    %% Interfaces
    class State {
        <<interface>>
        +selectProduct(productId: String)
        +insertCoin(coinValue: int)
        +processPayment()
        +dispenseProduct()
        +cancelTransaction()
        +getStateName() String
    }

    class PaymentStrategy {
        <<interface>>
        +processPayment(transaction: Transaction) boolean
        +getPaymentMethod() String
    }

    class ProductSelectionStrategy {
        <<interface>>
        +selectProduct(availableProducts: List~Product~, criteria: String) Product
        +getSelectionMethod() String
    }

    class VendingMachineObserver {
        <<interface>>
        +onProductSelected(productId: String)
        +onCoinInserted(coinValue: int)
        +onPaymentProcessed(amount: int, method: String)
        +onProductDispensed(productId: String)
        +onTransactionCompleted(transactionId: String)
        +onTransactionFailed(transactionId: String, reason: String)
        +onMaintenanceRequired(message: String)
    }

    %% Model Classes
    class Coin {
        -type: CoinType
        -value: int
        +Coin(type: CoinType)
        +getType() CoinType
        +getValue() int
        +toString() String
        +equals(obj: Object) boolean
        +hashCode() int
    }

    class Product {
        -id: String
        -type: ProductType
        -name: String
        -price: int
        -quantity: int
        +Product(id: String, type: ProductType, quantity: int)
        +getId() String
        +getType() ProductType
        +getName() String
        +getPrice() int
        +getQuantity() int
        +setQuantity(quantity: int)
        +isAvailable() boolean
        +decrementQuantity()
        +toString() String
        +equals(obj: Object) boolean
        +hashCode() int
    }

    class Inventory {
        -products: Map~String, Product~
        +Inventory()
        +addProduct(slotId: String, type: ProductType, quantity: int)
        +getProduct(slotId: String) Product
        +getAllProducts() Map~String, Product~
        +isProductAvailable(slotId: String) boolean
        +dispenseProduct(slotId: String) Product
        +restockProduct(slotId: String, quantity: int)
        +getTotalValue() int
        +getTotalItems() int
    }

    class Transaction {
        -transactionId: String
        -timestamp: LocalDateTime
        -productId: String
        -productPrice: int
        -insertedCoins: List~Coin~
        -paymentMethod: PaymentMethod
        -status: TransactionStatus
        -totalInsertedAmount: int
        +Transaction(transactionId: String, productId: String, productPrice: int, paymentMethod: PaymentMethod)
        +getTransactionId() String
        +getTimestamp() LocalDateTime
        +getProductId() String
        +getProductPrice() int
        +getInsertedCoins() List~Coin~
        +getPaymentMethod() PaymentMethod
        +getStatus() TransactionStatus
        +setStatus(status: TransactionStatus)
        +getTotalInsertedAmount() int
        +addCoin(coin: Coin)
        +isPaymentComplete() boolean
        +getChangeAmount() int
        +needsRefund() boolean
        +toString() String
    }

    %% State Pattern Implementation
    class IdleState {
        -context: VendingMachineContext
        +IdleState(context: VendingMachineContext)
        +selectProduct(productId: String)
        +insertCoin(coinValue: int)
        +processPayment()
        +dispenseProduct()
        +cancelTransaction()
        +getStateName() String
    }

    class SelectingState {
        -context: VendingMachineContext
        +SelectingState(context: VendingMachineContext)
        +selectProduct(productId: String)
        +insertCoin(coinValue: int)
        +processPayment()
        +dispenseProduct()
        +cancelTransaction()
        +getStateName() String
    }

    class PaymentState {
        -context: VendingMachineContext
        +PaymentState(context: VendingMachineContext)
        +selectProduct(productId: String)
        +insertCoin(coinValue: int)
        +processPayment()
        +dispenseProduct()
        +cancelTransaction()
        +getStateName() String
    }

    class DispensingState {
        -context: VendingMachineContext
        +DispensingState(context: VendingMachineContext)
        +selectProduct(productId: String)
        +insertCoin(coinValue: int)
        +processPayment()
        +dispenseProduct()
        +cancelTransaction()
        +getStateName() String
    }

    %% Strategy Pattern Implementation
    class CashPaymentStrategy {
        +processPayment(transaction: Transaction) boolean
        +getPaymentMethod() String
    }

    class CardPaymentStrategy {
        +processPayment(transaction: Transaction) boolean
        +getPaymentMethod() String
    }

    class MobilePaymentStrategy {
        +processPayment(transaction: Transaction) boolean
        +getPaymentMethod() String
    }

    class BasicProductSelectionStrategy {
        +selectProduct(availableProducts: List~Product~, criteria: String) Product
        +getSelectionMethod() String
    }

    class NameBasedSelectionStrategy {
        +selectProduct(availableProducts: List~Product~, criteria: String) Product
        +getSelectionMethod() String
    }

    %% Observer Pattern Implementation
    class ConsoleVendingObserver {
        +onProductSelected(productId: String)
        +onCoinInserted(coinValue: int)
        +onPaymentProcessed(amount: int, method: String)
        +onProductDispensed(productId: String)
        +onTransactionCompleted(transactionId: String)
        +onTransactionFailed(transactionId: String, reason: String)
        +onMaintenanceRequired(message: String)
    }

    class MaintenanceObserver {
        +onProductSelected(productId: String)
        +onCoinInserted(coinValue: int)
        +onPaymentProcessed(amount: int, method: String)
        +onProductDispensed(productId: String)
        +onTransactionCompleted(transactionId: String)
        +onTransactionFailed(transactionId: String, reason: String)
        +onMaintenanceRequired(message: String)
    }

    %% Main System Classes
    class VendingMachineContext {
        -currentState: State
        -currentTransaction: Transaction
        -inventory: Inventory
        -observers: List~VendingMachineObserver~
        -paymentStrategy: PaymentStrategy
        -productSelectionStrategy: ProductSelectionStrategy
        -machineId: String
        -isOperational: boolean
        +VendingMachineContext()
        +setCurrentState(state: State)
        +getCurrentState() State
        +getCurrentTransaction() Transaction
        +setCurrentTransaction(transaction: Transaction)
        +createTransaction(productId: String) Transaction
        +cancelCurrentTransaction()
        +getInventory() Inventory
        +displayInventory()
        +addObserver(observer: VendingMachineObserver)
        +removeObserver(observer: VendingMachineObserver)
        +notifyObservers(event: String, args: Object...)
        +getPaymentStrategy() PaymentStrategy
        +setPaymentStrategy(strategy: PaymentStrategy)
        +getProductSelectionStrategy() ProductSelectionStrategy
        +setProductSelectionStrategy(strategy: ProductSelectionStrategy)
        +returnChange(amount: int)
        +selectProduct(productId: String)
        +insertCoin(coinValue: int)
        +processPayment()
        +dispenseProduct()
        +cancelTransaction()
        +getMachineId() String
        +isOperational() boolean
        +setOperational(operational: boolean)
        +getMachineStatus() String
    }

    class VendingMachineSystem {
        -context: VendingMachineContext
        +VendingMachineSystem()
        +displayInventory()
        +selectProductBySlot(slotId: String)
        +selectProductByName(productName: String)
        +insertCoin(coinValue: int)
        +setPaymentMethod(paymentMethod: PaymentMethod)
        +processPayment()
        +cancelTransaction()
        +getMachineStatus() String
        +addObserver(observer: VendingMachineObserver)
        +getContext() VendingMachineContext
        +performMaintenance()
    }

    %% Relationships
    %% State Pattern
    State <|.. IdleState
    State <|.. SelectingState
    State <|.. PaymentState
    State <|.. DispensingState

    VendingMachineContext o-- State

    %% Strategy Pattern
    PaymentStrategy <|.. CashPaymentStrategy
    PaymentStrategy <|.. CardPaymentStrategy
    PaymentStrategy <|.. MobilePaymentStrategy

    ProductSelectionStrategy <|.. BasicProductSelectionStrategy
    ProductSelectionStrategy <|.. NameBasedSelectionStrategy

    VendingMachineContext o-- PaymentStrategy
    VendingMachineContext o-- ProductSelectionStrategy

    %% Observer Pattern
    VendingMachineObserver <|.. ConsoleVendingObserver
    VendingMachineObserver <|.. MaintenanceObserver

    VendingMachineContext o-- VendingMachineObserver

    %% Model Relationships
    Coin ..> CoinType
    Product ..> ProductType
    Transaction ..> PaymentMethod
    Transaction ..> TransactionStatus
    Transaction o-- Coin
    Inventory o-- Product

    %% Main System
    VendingMachineSystem o-- VendingMachineContext

    %% Notes
    note for VendingMachineContext "Context class that manages the state pattern and coordinates all components"
    note for State "State interface for the State design pattern"
    note for PaymentStrategy "Strategy interface for different payment methods"
    note for VendingMachineObserver "Observer interface for vending machine events"
```

## Design Patterns Used

### 1. State Pattern
- **Purpose**: Manages different states of the vending machine (Idle, Selecting, Payment, Dispensing)
- **Classes**: `State`, `IdleState`, `SelectingState`, `PaymentState`, `DispensingState`
- **Context**: `VendingMachineContext`

### 2. Strategy Pattern
- **Purpose**: Handles different payment methods and product selection strategies
- **Payment Strategies**: `CashPaymentStrategy`, `CardPaymentStrategy`, `MobilePaymentStrategy`
- **Selection Strategies**: `BasicProductSelectionStrategy`, `NameBasedSelectionStrategy`

### 3. Observer Pattern
- **Purpose**: Notifies different components about vending machine events
- **Subject**: `VendingMachineContext`
- **Observers**: `ConsoleVendingObserver`, `MaintenanceObserver`

### 4. Facade Pattern
- **Purpose**: Provides a simplified interface to the complex vending machine system
- **Facade**: `VendingMachineSystem`

## Key Features

1. **State Management**: The vending machine transitions between different states based on user actions
2. **Multiple Payment Methods**: Support for cash, card, and mobile payments
3. **Flexible Product Selection**: Can select products by slot ID or by name search
4. **Inventory Management**: Tracks product quantities and availability
5. **Transaction Handling**: Manages complete purchase transactions with proper error handling
6. **Observer Notifications**: Notifies different components about machine events
7. **Maintenance Monitoring**: Tracks inventory levels and machine status

## Usage Flow

1. Machine starts in `IdleState`
2. User selects a product → Machine transitions to `SelectingState`
3. User inserts coins → Coins are tracked in the current transaction
4. When payment is complete → Machine transitions to `PaymentState`
5. Payment is processed → Machine transitions to `DispensingState`
6. Product is dispensed → Machine returns to `IdleState`

This design provides a robust, extensible, and maintainable vending machine system that follows object-oriented design principles and common design patterns.
